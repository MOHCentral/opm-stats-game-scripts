// ============================================================================
// OpenMOHAA Telemetry Tracker - Common Helpers v2.0
// ============================================================================

// ============================================================================
// CONFIGURATION & GLOBALS
// ============================================================================
level.api_base_url = "http://localhost:8084"
    level.api_events_endpoint = "/api/v1/ingest/events"
    level.server_token = "8b6a271b-eed5-4e55-995a-d5494f3ca94b"
    level.server_id = "728ae814-a0c4-47d5-9dd7-82c0ab3c221d"
    level.tracker_debug = 1

    // Batching Globals
    level.event_queue = ""
    level.batch_size = 0
    level.max_batch_size = 20 // Flush immediately if this size reached

    // ============================================================================
    // HELPERS
    // ============================================================================

safestr local.val:
        if (local.val == NIL) {
            end "NIL"
        }
        if (local.val == NULL) {
            end "NULL"
        }
        // Check type - floats and ints need special handling
        local.t = typeof local.val
        if (local.t == "float" || local.t == "int" || local.t == "double") {
            end ("" + local.val)  // Numeric to string via concatenation
        }
        if (local.t == "listener") {
            // For listeners/entities, try to get netname or use targetname
            if (local.val.netname != NIL) {
                end local.val.netname
            }
            if (local.val.targetname != NIL) {
                end local.val.targetname
            }
            end "[entity]"
        }
        end ("" + local.val)
    end

debug_log_var local.a1 local.a2 local.a3 local.a4 local.a5 local.a6 local.a7 local.a8 local.a9 local.a10 local.a11 local.a12 local.a13 local.a14 local.a15 local.a16:
        if (level.tracker_debug) {
            local.msg = ""
            if (local.a1 != NIL) local.msg += (waitthread safestr local.a1)
                if (local.a2 != NIL) local.msg += (waitthread safestr local.a2)
                    if (local.a3 != NIL) local.msg += (waitthread safestr local.a3)
                        if (local.a4 != NIL) local.msg += (waitthread safestr local.a4)
                            if (local.a5 != NIL) local.msg += (waitthread safestr local.a5)
                                if (local.a6 != NIL) local.msg += (waitthread safestr local.a6)
                                    if (local.a7 != NIL) local.msg += (waitthread safestr local.a7)
                                        if (local.a8 != NIL) local.msg += (waitthread safestr local.a8)
                                            if (local.a9 != NIL) local.msg += (waitthread safestr local.a9)
                                                if (local.a10 != NIL) local.msg += (waitthread safestr local.a10)
                                                    if (local.a11 != NIL) local.msg += (waitthread safestr local.a11)
                                                        if (local.a12 != NIL) local.msg += (waitthread safestr local.a12)
                                                            if (local.a13 != NIL) local.msg += (waitthread safestr local.a13)
                                                                if (local.a14 != NIL) local.msg += (waitthread safestr local.a14)
                                                                    if (local.a15 != NIL) local.msg += (waitthread safestr local.a15)
                                                                        if (local.a16 != NIL) local.msg += (waitthread safestr local.a16)
        
                                                                            println ("[" + level.time + "] [OPM] " + local.msg)
        }
    end

    // ============================================================================
    // PLAYER PAYLOAD BUILDER
    // ============================================================================
build_player_payload local.player local.prefix:
        local.payload = ""

        // Check if player is valid - MUST be a listener/entity type
        if (local.player == NIL || local.player == NULL) {
            end local.payload
        }
        
        // Critical type check - prevent float/int being treated as entity
        local.ptype = typeof local.player
        if (local.ptype != "listener") {
            // Not an entity - could be -1, float, or other invalid type
            end local.payload
        }
        
        // Now safe to dereference .netname
        local.name = local.player.netname
        if (local.name == NIL) {
            end local.payload
        }

        local.guid = ""
        // PRIORITIZE PERSISTENT IDENTITY
        if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL && local.player.smf_member_id > 0) {
            local.guid = local.player.smf_member_id
        } else {
            // Fallback for unauthenticated players: "clientnum" is not persistent, but "name" is spoofable.
            // We use clientnum for unique match tracking.
            local.guid = "unauth_" + (getclientnum local.player)
        }

        // Core Identity
        local.payload = "&" + local.prefix + "_name=" + local.name
        local.payload = local.payload + "&" + local.prefix + "_guid=" + local.guid

        // SMF Identity (Explicit field)
        if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL) {
            local.payload = local.payload + "&" + local.prefix + "_smf_id=" + local.player.smf_member_id
        }

        // Team
        if (local.player.team != NIL && local.player.team != "") {
            local.payload = local.payload + "&" + local.prefix + "_team=" + local.player.team
        }

        // Location
        if (local.player.origin != NIL) {
            local.pos = local.player.origin
            local.payload = local.payload + "&" + local.prefix + "_x=" + local.pos[0]
            local.payload = local.payload + "&" + local.prefix + "_y=" + local.pos[1]
            local.payload = local.payload + "&" + local.prefix + "_z=" + local.pos[2]
        }

        // Angles
        if (local.player.angles != NIL) {
            local.ang = local.player.angles
            local.payload = local.payload + "&" + local.prefix + "_pitch=" + local.ang[0]
            local.payload = local.payload + "&" + local.prefix + "_yaw=" + local.ang[1]
        }
        
        // Stance
        local.stance = "stand"
        if (local.player.tracker_stance != NIL) {
            local.stance = local.player.tracker_stance
        }
        local.payload = local.payload + "&" + local.prefix + "_stance=" + local.stance

        end local.payload

build_player_payload_compact local.player local.prefix:
            local.payload = ""

            // Check if player is valid - MUST be a listener/entity type
            if (local.player == NIL || local.player == NULL || typeof local.player != "listener") {
                end local.payload
            }
            
            // Critical type check - prevent float/int being treated as entity
            local.ptype = typeof local.player
            if (local.ptype != "listener") {
                end local.payload
            }

            // Now safe to dereference .netname
            local.name = local.player.netname
            if (local.name == NIL) {
                end local.payload
            }

            local.guid = ""
            if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL && local.player.smf_member_id > 0) {
                local.guid = local.player.smf_member_id
            } else {
                local.guid = "unauth_" + (getclientnum local.player)
            }

            local.payload = "&" + local.prefix + "_name=" + local.name
            local.payload = local.payload + "&" + local.prefix + "_guid=" + local.guid

            if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL) {
                local.payload = local.payload + "&" + local.prefix + "_smf_id=" + local.player.smf_member_id
            }

            if (local.player.team != NIL && local.player.team != "") {
                local.payload = local.payload + "&" + local.prefix + "_team=" + local.player.team
            }

            end local.payload

            // ============================================================================
            // BATCHING SYSTEM
            // ============================================================================

queue_event local.payload:
            // Guard against NIL payload
                if (local.payload == NIL) end
                    if (local.payload == "") end

                        // Ensure globals are initialized
                if (level.event_queue == NIL) {
                    level.event_queue = ""
                }
                if (level.batch_size == NIL) {
                    level.batch_size = 0
                }
                if (level.max_batch_size == NIL) {
                    level.max_batch_size = 20
                }
                if (level.server_token == NIL) {
                    level.server_token = "unregistered"
                }
                if (level.server_id == NIL) {
                    level.server_id = "0"
                }

                // Append server identification to each event
                local.full_payload = local.payload + "&server_token=" + level.server_token
                local.full_payload = local.full_payload + "&server_id=" + level.server_id

                if (level.event_queue == NIL || level.event_queue == "") {
                    level.event_queue = local.full_payload
                } else {
                    level.event_queue = level.event_queue + "\n" + local.full_payload
                }
    
                level.batch_size++
    
                if (level.batch_size >= level.max_batch_size) {
                    thread flush_queue
                }
            end

flush_queue:
                if (level.event_queue == NIL || level.event_queue == "") {
                    end
                }

                local.payload_to_send = level.event_queue
                level.event_queue = ""
                level.batch_size = 0

                local.url = level.api_base_url + level.api_events_endpoint
    
                //if (level.tracker_debug) {
                //    println ("API BATCH FLUSH: " + local.url)
                //}
    
                // TODO: curl_post not available in this engine build
                //println ("[STUB] Would POST batch to: " + local.url)
                // curl_post local.url local.payload_to_send "tracker_common.scr::on_http_callback"
            end

flush_loop:
                while (1) {
                    wait 2
                    thread flush_queue
                }
            end



            // ============================================================================
            // HELPERS
            // ============================================================================

on_http_callback local.success local.response local.http_code:
                if (level.tracker_debug) {
                    if (local.success) {
                        println ("HTTP OK [" + local.http_code + "]")
                    } else {
                        println ("HTTP FAIL [" + local.http_code + "]: " + local.response)
                    }
                }
            end

build_base_payload local.event_type:
                if (local.event_type == NIL) { local.event_type = "unknown" }
                    local.payload = "type=" + local.event_type
    
                local.match_id = level.match_id
                if (local.match_id == NIL) { local.match_id = "no_match" }
                    local.payload = local.payload + "&match_id=" + local.match_id
    
                local.payload = local.payload + "&timestamp=" + level.time

                if (level.session_id != NIL && level.session_id != "") {
                    local.payload = local.payload + "&session_id=" + level.session_id
                }

                if (level.map_name != NIL && level.map_name != "") {
                    local.payload = local.payload + "&map_name=" + level.map_name
                }

                end local.payload

debug_log local.message:
                    if (level.tracker_debug) {
                        local.safe_msg = waitthread safestr local.message
                        println ("[" + level.time + "] [OPM] " + local.safe_msg)
                    }
                end

                // ============================================================================
                // STRING HELPERS
                // ============================================================================
                // Returns the index of 'search' within 'str', starting from 'start'
str_indexof local.str local.search local.start:
                    if (local.start == NIL) { local.start = 0 }
                        if (local.str == NIL || local.search == NIL) { end -1 }
    
                            local.str_len = local.str.size
                    local.search_len = local.search.size
    
                    if (local.str_len == NIL || local.search_len == NIL) { end -1 }
                        if (local.search_len == 0) { end local.start }
                            if (local.search_len > local.str_len) { end -1 }
    
                                local.end_idx = (local.str_len - local.search_len)
                    if (local.end_idx == NIL) { end -1 }

                        for (local.i = local.start; local.i <= local.end_idx; local.i++) {
                        local.found = 1
                        for (local.j = 0; local.j < local.search_len; local.j++) {
                            if (local.str[local.i + local.j] != local.search[local.j]) {
                                local.found = 0
                                break
                            }
                        }
                        if (local.found) { end local.i }
                    }
                    end -1

                    // ============================================================================
                    // JSON HELPERS (Basic Parsing)
                    // ============================================================================
                    // Extracts a string value from a simple JSON object: {"key":"value"}
json_get_string local.json local.key:
                        if (local.json == NIL || local.key == NIL) { end "" }
                            local.quote = "\"" // This is standard in SCR
                        local.key_quoted = local.quote + local.key + local.quote
                        local.key_index = waitthread str_indexof local.json local.key_quoted
                        if (local.key_index == -1) { end "" }

                            // Find colon after key
                        local.colon_index = waitthread str_indexof local.json ":" (local.key_index + local.key_quoted.size)
                        if (local.colon_index == -1) { end "" }

                            // Find first quote after colon
                        local.start_quote = waitthread str_indexof local.json local.quote (local.colon_index + 1)
                        if (local.start_quote == -1) { end "" }

                            // Find end quote
                        local.end_quote = waitthread str_indexof local.json local.quote (local.start_quote + 1)
                        if (local.end_quote == -1) { end "" }

                            local.result = ""
                        for (local.i = (local.start_quote + 1); local.i < local.end_quote; local.i++) {
                            local.result = local.result + local.json[local.i]
                        }
                        end local.result

                        // Extracts an integer value from a simple JSON object: {"key":123}
json_get_int local.json local.key:
                            if (local.json == NIL || local.key == NIL) { end 0 }
                                local.quote = "\"" // This is standard in SCR
                            local.key_quoted = local.quote + local.key + local.quote
                            local.key_index = waitthread str_indexof local.json local.key_quoted
                            if (local.key_index == -1) { end 0 }

                                // Find colon after key
                            local.colon_index = waitthread str_indexof local.json ":" (local.key_index + local.key_quoted.size)
                            if (local.colon_index == -1) { end 0 }

                                // Start after colon, skip spaces
                            local.start = local.colon_index + 1
                            local.json_size = local.json.size
                            if (local.json_size == NIL) { end 0 }
    
                                while (local.start < local.json_size && (local.json[local.start] == " " || local.json[local.start] == "\t")) {
                                local.start++
                            }

                            local.result_str = ""
                            local.i = local.start
                            while (local.i < local.json_size) {
                                local.char = local.json[local.i]
                                if (local.char >= "0" && local.char <= "9") {
                                    local.result_str = local.result_str + local.char
                                } else if (local.char == "-" && local.result_str == "") {
                                    local.result_str = local.result_str + local.char
                                } else {
                                    break
                                }
                                local.i++
                            }

                            if (local.result_str == "") { end 0 }
                                end (int local.result_str)
