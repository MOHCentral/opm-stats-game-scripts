// ============================================================================
// OpenMOHAA Telemetry Tracker v2.0
// High-Throughput Event Collection for Mass Stats System
// ============================================================================
//
// This tracker sends atomic events directly to the API.
// The API handles batching, worker pools, and database writes.
//
// Architecture:
// - Events fire immediately via curl_post (no client-side batching)
// - URL-encoded payloads with rich metadata (positions, angles, timestamps)
// - Server session/match context included in each event
// - API returns 202 Accepted immediately (async processing)
//
// ============================================================================
// MAIN INITIALIZATION
// ============================================================================

main:
// ========================================================================
// CONFIGURATION - Must be inside a label to execute!
// ========================================================================
level.api_base_url = "http://localhost:8084"
        level.api_events_endpoint = "/api/v1/ingest/events"

        // Fetch Identity from CVars (Critical for Multi-Server)
        level.server_token = getcvar "opm_server_token"
        
        // Check for "poisoned" config value
        local.bad_token = 0
        if (level.server_token != NIL && level.server_token != "") {
            local.idx = waitthread global/tracker_common.scr::str_indexof level.server_token "MISSING_TOKEN"
            if (local.idx != -1) { local.bad_token = 1 }
        }

        if (level.server_token == "" || local.bad_token == 1) {
            level.server_token = "4d170d00-8b08-4619-93d0-cec2ad7883e2"
            println "WARNING: opm_server_token invalid/missing! Using Dev Token."
        }

        level.server_id = getcvar "opm_server_id"
        if (level.server_id == "") {
            level.server_id = "c258243d-eacd-4ef3-8af7-5efa065606ce"
            println "WARNING: opm_server_id not set! Using Dev ID."
        }

        // Session tracking
        level.session_id = ""
        level.match_id = ""
        level.match_start_time = 0
        level.round_number = 0
        level.map_name = ""

        // Team scores (for heartbeat)
        level.allies_score = 0
        level.axis_score = 0

        // Debug - Default to CVar, fallback to 1
        local.debug_cvar = getcvar "opm_debug"
        if (local.debug_cvar == "") {
            setcvar "opm_debug" "1"
            level.tracker_debug = 1
        } else {
            level.tracker_debug = (int local.debug_cvar)
        }

        println "=============================================="
        println "OpenMOHAA Telemetry Tracker v2.0 Initializing"
        println "=============================================="
    
        // Generate robust session ID (ServerID + Time + Random)
        local.rnd = randomint 999999
        level.session_id = "sess_" + level.time + "_" + local.rnd
        level.match_start_time = level.time
        level.map_name = getcvar "mapname"
    
        local.sid_msg = "Session ID: " + level.session_id
        println local.sid_msg
        local.map_msg = "Map: " + level.map_name
        println local.map_msg
        local.api_msg = "API Endpoint: " + level.api_base_url + level.api_events_endpoint
        println local.api_msg
    
        // Register console commands
        registercmd "login" "cmd_login"
        registercmd "logout" "cmd_logout"
        registercmd "claim" "cmd_claim"
        registercmd "stats" "cmd_stats"
        registercmd "whoami" "cmd_whoami"
        registercmd "seed" seed_cmd_wrapper

        // ========================================================================
        // EVENT SUBSCRIPTIONS
        // ========================================================================
        // Initialization logic is split into separate scripts for organization.
        
        thread global/tracker_init_player.scr::init
        thread global/tracker_init_server.scr::init

        // Life-Cycle Events (handled in tracker_init_server.scr now)
        // server_process_start and server_process_quit are one-time only
        event_subscribe "server_process_start" on_server_process_start
        event_subscribe "server_process_quit"  on_server_process_quit

    
        println "Subscribed to all 94 events."
    
        // Send match_start event (Generates unique match_id)
        // thread send_match_start  // <-- Moved to on_map_start handler
    
        // Start heartbeat loop (every 30 seconds)
        thread heartbeat_loop
        
        // Start debug CVar sync loop
        thread debug_sync_loop
        
        // Start API flush loop (every 2 seconds)
        thread global/tracker_common.scr::flush_loop
        
        // Check for auto-seed cvar (opm_seed)
        // Usage: +set opm_seed 5 on command line to seed 5 matches on startup
        local.seed_count = getcvar "opm_seed"
        if (local.seed_count != NIL && local.seed_count != "" && local.seed_count != "0") {
            println ("AUTO-SEED: opm_seed cvar set to " + local.seed_count + ", starting seeder...")
            wait 2
            thread global/seeder.scr::cmd_seed NIL local.seed_count
        }

    
        // ============================================================================
        // PLAYER HUD MANAGER 
        // ============================================================================
        // Note: HUD Draw implementation deferred until engine support confirmed.
        // Currently using iprintln for notifications.
        // ============================================================================

player_hud_manager:
        // Empty placeholder - waiting for hud_draw documentation/examples
        // When implemented, this will:
        // 1. Track active players and their HUD elements
        // 2. Update kill/death counters on HUD
        // 3. Show achievement notifications
        // 4. Display session stats
        end

        // ============================================================================
        // HUD NOTIFICATION SYSTEM
        // ============================================================================

show_hud_notification local.player local.message local.r local.g local.b:
            if (!local.player) end
        
                // Use iprint instead of hudprint (which doesn't exist)
            local.msg = (">>> " + local.message)
            iprint local.msg
        end

        // ============================================================================
        // CONSOLE COMMANDS
        // ============================================================================
        // These commands integrate with the SMF forum login token system.
        // Players generate tokens at the forum and use them in-game to link identities.
        // Once authenticated, the SMF member_id is used for all stat tracking.
        // ============================================================================

        // Wrapper for seed command (external script)
seed_cmd_wrapper local.player local.args:
            thread global/seeder.scr::cmd_seed local.player local.args
        end

cmd_login local.player local.args:
            if (local.args.size < 1) {
                iprintln "Usage: login <token>"
                iprintln "Get your token from the forum: /action=mohaatoken"
                end
            }
    
            local.token = local.args[0]
    
            // Store pending auth info on player
            local.player.pending_auth_token = local.token
            local.player.is_authenticated = 0
            local.player.smf_member_id = 0
    
            iprintln "Verifying login token..."
            println ("Player " + local.player.netname + " attempting auth with SMF token")
    
            // HUD Notification: Verifying
            thread show_hud_notification local.player "Verifying Token..." 1.0 1.0 0.0 // Yellow
    
            // Call SMF auth API endpoint
            // This verifies the token and returns the SMF member_id
            local.url = level.api_base_url + "/api/v1/auth/smf-verify"
            local.data = "token=" + local.token
            local.data = local.data + "&guid=" + (getclientnum local.player)
            local.data = local.data + "&player_name=" + local.player.netname
            local.data = local.data + "&server_ip=" + (getcvar "net_ip")
            local.data = local.data + "&server_port=" + (getcvar "net_port")
            local.data = local.data + "&server_id=" + level.server_id
    
            // No longer storing global reference to avoid race conditions
            // level.pending_auth_player = local.player  <-- REMOVED

            // TODO: curl_post not available in this engine build
            println ("[STUB] Would POST to: " + local.url)
            curl_post local.url local.data "on_smf_auth_verify"
        end

cmd_logout local.player local.args:
            if (!local.player.is_authenticated) {
                iprintln "You are not logged in."
                end
            }
    
            // Send logout notification to SMF
            local.url = level.api_base_url + "/api/v1/auth/smf-logout"
            local.data = "member_id=" + local.player.smf_member_id
            local.data = local.data + "&guid=" + (getclientnum local.player)
            // TODO: curl_post not available in this engine build
            println ("[STUB] Would POST logout to: " + local.url)
            curl_post local.url local.data "on_http_callback"
    
            // Clear auth state
            local.player.is_authenticated = 0
            local.player.smf_member_id = 0
            local.player.smf_member_name = ""
            local.player.auth_token = ""
    
            iprintln "You have been logged out."
            println ("Player " + local.player.netname + " logged out")
    
            // HUD Notification: Logged Out
            thread show_hud_notification local.player "Logged Out" 0.7 0.7 0.7 // Grey
        end

cmd_claim local.player local.args:
        // This is now handled through the SMF login system
        // Players link their identity by logging in with their forum token
            iprintln "Identity linking is now done through forum login."
            iprintln "Visit the forum and generate a login token, then use /login <token>"
        end

cmd_stats local.player local.args:
            iprintln "Fetching your stats..."
    
            // Use SMF member_id if authenticated, otherwise use GUID
            if (local.player.is_authenticated && local.player.smf_member_id > 0) {
                local.url = level.api_base_url + "/api/v1/stats/member/" + local.player.smf_member_id
            } else {
                local.url = level.api_base_url + "/api/v1/stats/player/" + (getclientnum local.player)
            }
    
            // TODO: curl_get not available in this engine build
            println ("[STUB] Would GET stats from: " + local.url)
            curl_get local.url "on_stats_response"
        end

cmd_whoami local.player local.args:
            if (local.player.is_authenticated) {
                iprintln ("Logged in as: " + local.player.smf_member_name + " (ID: " + local.player.smf_member_id + ")")
            } else {
                iprintln "Not logged in. Use /login <token> to authenticate."
            }
        end

        // ============================================================================
        // MATCH LIFECYCLE EVENTS
        // ============================================================================

send_match_start:
            local.rnd = randomint 999999
            level.match_id = "match_" + level.session_id + "_" + level.time + "_" + local.rnd
            level.round_number = 1
    
            local.payload = waitthread global/tracker_common.scr::build_base_payload "match_start"
            local.payload = local.payload + "&server_id=" + level.server_id
            local.payload = local.payload + "&map_name=" + level.map_name
            local.payload = local.payload + "&gametype=" + (getcvar "g_gametype")
            local.payload = local.payload + "&timelimit=" + (getcvar "timelimit")
            local.payload = local.payload + "&fraglimit=" + (getcvar "fraglimit")
            local.payload = local.payload + "&maxclients=" + (getcvar "sv_maxclients")
    
            thread global/tracker_common.scr::queue_event local.payload
            println ("MATCH START: " + level.match_id)
        end

send_match_end local.winning_team local.allies_score local.axis_score:
            if (local.winning_team == NIL) { local.winning_team = "unknown" }
                if (local.allies_score == NIL) { local.allies_score = 0 }
                    if (local.axis_score == NIL) { local.axis_score = 0 }
                        local.round = level.round_number
            local.map = level.map_name
            local.duration = level.time - level.match_start_time
            if (local.round == NIL) { local.round = 0 }
                if (local.map == NIL) { local.map = "unknown" }
                    if (local.duration == NIL) { local.duration = 0 }
                        local.payload = waitthread global/tracker_common.scr::build_base_payload "match_end"
            local.payload = local.payload + "&server_id=" + level.server_id
            local.payload = local.payload + "&map_name=" + local.map
            local.payload = local.payload + "&duration=" + local.duration
            local.payload = local.payload + "&winning_team=" + local.winning_team
            local.payload = local.payload + "&allies_score=" + local.allies_score
            local.payload = local.payload + "&axis_score=" + local.axis_score
            local.payload = local.payload + "&total_rounds=" + local.round
    
            thread global/tracker_common.scr::queue_event local.payload
            println ("MATCH END: " + level.match_id + " Winner: " + local.winning_team)
        end

send_round_start:
            level.round_number = (level.round_number + 1)
            if (level.round_number == NIL) level.round_number = 1

                local.payload = waitthread global/tracker_common.scr::build_base_payload "round_start"
            local.payload = local.payload + "&round_number=" + level.round_number

            thread global/tracker_common.scr::queue_event local.payload
        end

send_round_end local.winning_team:
            local.round = level.round_number
            if (local.round == NIL) { local.round = 0 }
                if (local.winning_team == NIL) { local.winning_team = "unknown" }
                    local.payload = waitthread global/tracker_common.scr::build_base_payload "round_end"
            local.payload = local.payload + "&round_number=" + local.round
            local.payload = local.payload + "&winning_team=" + local.winning_team

            thread global/tracker_common.scr::queue_event local.payload
        end

heartbeat_loop:
            wait 30

            local.round = level.round_number
            local.allies = level.allies_score
            local.axis = level.axis_score
            local.pcount = level.playercount
            if (local.round == NIL) { local.round = 0 }
                if (local.allies == NIL) { local.allies = 0 }
                    if (local.axis == NIL) { local.axis = 0 }
                        if (local.pcount == NIL) { local.pcount = 0 }

                            local.payload = waitthread global/tracker_common.scr::build_base_payload "heartbeat"
            local.payload = local.payload + "&round_number=" + local.round
            local.payload = local.payload + "&allies_score=" + local.allies
            local.payload = local.payload + "&axis_score=" + local.axis
            local.payload = local.payload + "&player_count=" + local.pcount

            thread global/tracker_common.scr::queue_event local.payload
            thread heartbeat_loop
        end

debug_sync_loop:
            while (1) {
                wait 5
                local.debug_val = getcvar "opm_debug"
                if (local.debug_val != "") {
                    level.tracker_debug = (int local.debug_val)
                }
            }
        end

        // ============================================================================
        // COMBAT EVENT HANDLERS
        // ============================================================================
        // MOVED TO: global/tracker_combat_ext.scr
        // ============================================================================

        // ============================================================================
        // MOVEMENT EVENT HANDLERS
        // ============================================================================

on_player_jump local.player:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_jump | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    local.payload = waitthread global/tracker_common.scr::build_base_payload "jump"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_player_land local.player local.height:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_land | Player: " local.player " | Height: " local.height
            if (local.player == NIL) end
                if (!local.player) end
                    if (local.height == NIL) { local.height = 0 }
                        local.payload = waitthread global/tracker_common.scr::build_base_payload "land"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
            local.payload = local.payload + "&fall_height=" + local.height
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_player_crouch local.player:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_crouch | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    local.player.tracker_stance = "crouch"
            local.payload = waitthread global/tracker_common.scr::build_base_payload "crouch"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_player_prone local.player:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_prone | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    local.player.tracker_stance = "prone"
            local.payload = waitthread global/tracker_common.scr::build_base_payload "prone"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_player_distance local.player local.walked local.sprinted local.swam local.driven:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_distance | Player: " local.player " | Walked: " local.walked " | Sprinted: " local.sprinted
            if (local.player == NIL) end
                if (!local.player) end
                    if (local.walked == NIL) { local.walked = 0 }
                        if (local.sprinted == NIL) { local.sprinted = 0 }
                            if (local.swam == NIL) { local.swam = 0 }
                                if (local.driven == NIL) { local.driven = 0 }
                                    local.payload = waitthread global/tracker_common.scr::build_base_payload "distance"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
            local.payload = local.payload + "&walked=" + local.walked
            local.payload = local.payload + "&sprinted=" + local.sprinted
            local.payload = local.payload + "&swam=" + local.swam
            local.payload = local.payload + "&driven=" + local.driven
    
            thread global/tracker_common.scr::queue_event local.payload
        end

        // ============================================================================
        // INTERACTION EVENT HANDLERS
        // ============================================================================

on_ladder_mount local.player local.ladder:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_ladder_mount | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    local.payload = waitthread global/tracker_common.scr::build_base_payload "ladder_mount"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_ladder_dismount local.player local.ladder:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_ladder_dismount | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    local.payload = waitthread global/tracker_common.scr::build_base_payload "ladder_dismount"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
    
            thread global/tracker_common.scr::queue_event local.payload
        end

        // MOVED TO: global/tracker_items_ext.scr

on_player_use local.player local.entity:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_use | Player: " local.player " | Entity: " local.entity
            if (local.player == NIL) end
                if (!local.player) end
                    if (local.entity == NIL) { local.entity = "unknown" }
                        local.payload = waitthread global/tracker_common.scr::build_base_payload "use"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
            local.payload = local.payload + "&entity=" + local.entity
    
            thread global/tracker_common.scr::queue_event local.payload
        end

        // ============================================================================
        // SESSION EVENT HANDLERS
        // ============================================================================

on_client_connect local.clientnum:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_client_connect | ClientNum: " local.clientnum
            if (local.clientnum == NIL) { local.clientnum = -1 }
                local.payload = waitthread global/tracker_common.scr::build_base_payload "connect"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload self "player"
            local.payload = local.payload + "&client_num=" + local.clientnum
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_client_disconnect local.player:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_client_disconnect | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    local.payload = waitthread global/tracker_common.scr::build_base_payload "disconnect"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
    
            thread global/tracker_common.scr::queue_event local.payload
        end

on_client_begin local.player:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_client_begin | Player: " local.player
            if (local.player == NIL) end
                if (!local.player) end
                    // Initialize session-based counters
            local.player.shots_fired = 0
            local.player.shots_hit = 0
        
            // Initialize stance
            local.player.tracker_stance = "stand"

            local.payload = waitthread global/tracker_common.scr::build_base_payload "client_begin"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"

            thread global/tracker_common.scr::queue_event local.payload
    
            // Start per-player accuracy summary thread
            thread player_accuracy_loop local.player
        end

player_accuracy_loop local.player:
            while (local.player) {
                wait 10 // Every 10 seconds send summary
        
                if (!local.player) end

                    if (local.player.shots_fired > 0) {
                    local.payload = waitthread global/tracker_common.scr::build_base_payload "accuracy_summary"
                    local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload_compact local.player "player"
                    local.payload = local.payload + "&fired=" + local.player.shots_fired
                    local.payload = local.payload + "&hits=" + local.player.shots_hit
            
                    thread global/tracker_common.scr::queue_event local.payload
                }
            }
        end

on_team_join local.player local.old_team local.new_team:
            waitthread global/tracker_common.scr::debug_log_var "EVENT: on_team_join | Player: " local.player " | NewTeam: " local.new_team
            if (local.player == NIL) end
                if (!local.player) end
                    if (local.old_team == NIL) { local.old_team = "unknown" }
                        if (local.new_team == NIL) { local.new_team = "unknown" }
                            local.payload = waitthread global/tracker_common.scr::build_base_payload "team_join"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
            local.payload = local.payload + "&old_team=" + local.old_team
            local.payload = local.payload + "&new_team=" + local.new_team

            thread global/tracker_common.scr::queue_event local.payload
        end

        // on_player_say is handled in tracker_interaction_ext.scr

        // ============================================================================
        // HTTP TRANSPORT LAYER
        // ============================================================================


on_http_callback local.success local.response local.http_code:
            if (level.tracker_debug) {
                if (local.success) {
                    println ("HTTP OK [" + local.http_code + "]")
                } else {
                    println ("HTTP FAIL [" + local.http_code + "]: " + local.response)
                }
            }
        end

        // ============================================================================
        // SMF AUTHENTICATION CALLBACKS
        // ============================================================================
        // These handle responses from the SMF login token verification system.
        // On success, we store the SMF member_id on the player for use in all events.
        // ============================================================================

on_smf_auth_verify local.success local.response local.http_code:
            if (local.success && local.http_code == 200) {
                // Parse JSON response to get member_id and member_name
                // Response format: {"success":true,"member_id":123,"member_name":"PlayerName","guid":"xxx"}
                println ("SMF Auth response: " + local.response)
        
                // 1. EXTRACT DATA
                local.member_id = waitthread global/tracker_common.scr::json_get_int local.response "member_id"
                local.member_name = waitthread global/tracker_common.scr::json_get_string local.response "member_name"
            
                // Extract the GUID (clientnum) correctly based on JSON format (it might be int or string)
                // We try int first as getclientnum returns int
                local.target_guid_int = waitthread global/tracker_common.scr::json_get_int local.response "guid"
            
                // 2. FIND PLAYER BY CLIENTNUM
                local.player = NIL
                for (local.i = 1; local.i <= $player.size; local.i++) {
                    if ((getclientnum $player[local.i]) == local.target_guid_int) {
                        local.player = $player[local.i]
                        break
                    }
                }

                // If player not found (disconnected?), abort
                if (!local.player) {
                    println ("SMF Auth: Player with clientnum " + local.target_guid_int + " not found (disconnected?)")
                    end
                }
        
                if (local.member_id > 0) {
                    // SUCCESS - Store SMF identity on player
                    local.player.is_authenticated = 1
                    local.player.smf_member_id = local.member_id
                    local.player.smf_member_name = local.member_name
                    // Use the token they just sent (we don't have it here in callback unless echoed, 
                    // but we actually store it in pending_auth_token on player earlier... 
                    // Wait, simply reading it from player is fine now that we found the RIGHT player)
                    local.player.auth_token = local.player.pending_auth_token
            
                    iprintln ("Welcome, " + local.member_name + "! You are now logged in.")
                    iprintln "Your stats will be tracked to your forum account."
                    println ("SMF Auth SUCCESS: " + local.player.netname + " -> member_id=" + local.member_id)
            
                    // HUD Notification: Success
                    thread show_hud_notification local.player ("Welcome " + local.member_name + "!") 0.0 1.0 0.0 // Green
            
                    // Send login event to API with SMF member_id
                    thread send_player_auth_event local.player
                } else {
                    local.player.is_authenticated = 0
                    iprintln "Login failed: Could not verify token."
                    println ("SMF Auth FAIL: No member_id in response")
                    // HUD Notification: Fail
                    thread show_hud_notification local.player "Login Failed: Invalid Response" 1.0 0.0 0.0 // Red
                }
            } else {
                // For failures, we can't notify the specific player easily without the GUID echoed in error response.
                // If the API returns JSON even on error with GUID, we could parse it.
                // Assuming generic fail for now or we could parse response if it follows same structure.
                println ("SMF Auth FAIL: " + local.http_code + " - " + local.response)
            }
        end

send_player_auth_event local.player:
            local.payload = waitthread global/tracker_common.scr::build_base_payload "player_auth"
            local.payload = local.payload + waitthread global/tracker_common.scr::build_player_payload local.player "player"
            local.payload = local.payload + "&smf_member_id=" + local.player.smf_member_id
            local.payload = local.payload + "&smf_member_name=" + local.player.smf_member_name

            thread global/tracker_common.scr::queue_event local.payload
        end

on_auth_verify local.success local.response local.http_code:
        // Legacy callback - redirect to SMF auth
            if (local.success && local.http_code == 200) {
                println ("Legacy auth verified: " + local.response)
                iprintln "Authentication successful!"
            } else {
                println ("Legacy auth failed: " + local.response)
                iprintln "Authentication failed. Check your token."
            }
        end

on_claim_response local.success local.response local.http_code:
            if (local.success && local.http_code == 200) {
                iprintln "Identity claimed! Your stats are now linked."
            } else if (local.http_code == 404) {
                iprintln "Invalid claim code. Try again."
            } else {
                iprintln "Claim failed. Try again later."
            }
        end

on_stats_response local.success local.response local.http_code:
            if (local.success) {
                iprintln "Stats fetched - check console"
                println ("Stats: " + local.response)
            } else {
                iprintln "Could not fetch stats."
            }
        end

        // ============================================================================
        // ENGINE LIFE-CYCLE HANDLERS (New OPM Spec)
        // ============================================================================

on_server_process_start:
            println "------------------------------------------------"
            println "OPM TRACKER: Server Process Start"
            println "------------------------------------------------"
            // Handle registration once per process
            thread global/register.scr::check_registration
        end

on_server_process_quit:
            println "------------------------------------------------"
            println "OPM TRACKER: Server Process Quit"
            println "------------------------------------------------"
            // Final emergency flush
            waitthread global/tracker_common.scr::flush_queue
        end

on_map_init:
            if (level.tracker_debug) {
                println "OPM TRACKER: Map Init"
            }
            thread global/tracker_gameflow_ext.scr::on_map_init
        end

on_map_start local.dummy:
            println "------------------------------------------------"
            println "OPM TRACKER: Map Start"
            println "------------------------------------------------"
            // Re-initialize map/round state
            level.round_number = 1
            level.match_start_time = level.time
    
            // Call extension and send match_start telemetry
            thread global/tracker_gameflow_ext.scr::on_map_start
            thread send_match_start
        end

on_map_ready local.dummy:
            if (level.tracker_debug) {
                println "OPM TRACKER: Map Ready (Entities Spawned)"
            }
            thread global/tracker_gameflow_ext.scr::on_map_ready (getcvar "mapname") (getcvar "g_gametype")
        end

on_map_shutdown:
            println "------------------------------------------------"
            println "OPM TRACKER: Map Shutdown"
            println "------------------------------------------------"
    
            // Call extension
            thread global/tracker_gameflow_ext.scr::on_map_shutdown

            // Final map-level flush
            waitthread global/tracker_common.scr::flush_queue
        end
