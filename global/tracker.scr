// ============================================================================
// OpenMOHAA Telemetry Tracker v2.0
// High-Throughput Event Collection for Mass Stats System
// ============================================================================
//
// This tracker sends atomic events directly to the API.
// The API handles batching, worker pools, and database writes.
//
// Architecture:
// - Events fire immediately via // curl_post (no client-side batching)
// - URL-encoded payloads with rich metadata (positions, angles, timestamps)
// - Server session/match context included in each event
// - API returns 202 Accepted immediately (async processing)
//
// ============================================================================
// MAIN INITIALIZATION
// ============================================================================

main:
// ========================================================================
// CONFIGURATION - Must be inside a label to execute!
// NOTE: Using game.* for cross-script sharing. level.* is script-local!
// ========================================================================
    game.api_base_url = "http://localhost:8084"
    game.api_events_endpoint = "/api/v1/ingest/events"

    // Fetch Identity from CVars (Critical for Multi-Server)
    game.server_token = getcvar "opm_server_token"
        
    // Check for "poisoned" config value
    local.bad_token = 0
    if (game.server_token != NIL && game.server_token != "") {
        local.idx = waitthread global/tracker_common.scr::str_indexof game.server_token "MISSING_TOKEN"
        if (local.idx != -1) { local.bad_token = 1 }
    }

    if (game.server_token == "" || local.bad_token == 1) {
        dprintln "WARNING: opm_server_token invalid/missing!"
    }

    game.server_id = getcvar "opm_server_id"
    if (game.server_id == "") {
        dprintln "WARNING: opm_server_id not set!"
    }

    // Session tracking
    game.session_id = ""
    game.match_id = ""
    game.match_start_time = 0
    game.round_number = 0
    game.map_name = ""

    // Team scores (for heartbeat)
    game.allies_score = 0
    game.axis_score = 0

    // Debug - Default to CVar, fallback to 1
    local.debug_cvar = getcvar "opm_tracker_debug"
    if (local.debug_cvar == "") {            
        game.tracker_debug = 0
    } else {
        game.tracker_debug = (int local.debug_cvar)
    }

    dprintln "=============================================="
    dprintln "OpenMOHAA Telemetry Tracker v2.0 Initializing"
    dprintln "=============================================="
    
    // Generate robust session ID (ServerID + Time + Random)
    local.rnd = uuid_string 16
    game.session_id = "sess_" + local.rnd
    game.match_start_time = gettime
    game.map_name = getcvar "mapname"
    
    local.sid_msg = "Session ID: " + game.session_id
    dprintln local.sid_msg
    local.map_msg = "Map: " + game.map_name
    dprintln local.map_msg
    local.api_msg = "API Endpoint: " + game.api_base_url + game.api_events_endpoint
    dprintln local.api_msg
    
    // Register console commands
    registercmd "login" "cmd_login"
    registercmd "logout" "cmd_logout"
    registercmd "claim" "cmd_claim"
    registercmd "stats" "cmd_stats"
    registercmd "whoami" "cmd_whoami"
    registercmd "seed" seed_cmd_wrapper

    // ========================================================================
    // EVENT SUBSCRIPTIONS
    // ========================================================================
    // Initialization logic is split into separate scripts for organization.
        
    thread global/tracker_init_player.scr::init
    thread global/tracker_init_server.scr::init

    // Life-Cycle Events (handled in tracker_init_server.scr now)
    // server_process_start and server_process_quit are one-time only
    event_subscribe "server_process_start" on_server_process_start
    event_subscribe "server_process_quit"  on_server_process_quit

    
    dprintln "Subscribed to all 94 events."
    
    // Send match_start event (Generates unique match_id)
    // thread send_match_start  // <-- Moved to on_map_start handler
    
    // Start heartbeat loop (every 30 seconds)
    thread heartbeat_loop
        
    // Start debug CVar sync loop
    thread debug_sync_loop
        
    // Start API flush loop (every 2 seconds)
    thread global/tracker_common.scr::flush_loop
        
    // Check for auto-seed cvar (opm_seed)
    // Usage: +set opm_seed 5 on command line to seed 5 matches on startup
    local.seed_count = getcvar "opm_seed"
    if (local.seed_count != NIL && local.seed_count != "" && local.seed_count != "0") {
        dprintln ("AUTO-SEED: opm_seed cvar set to " + local.seed_count + ", starting seeder...")
        wait 2
        thread global/seeder.scr::cmd_seed NIL local.seed_count
    }

    
    // ============================================================================
    // PLAYER HUD MANAGER 
    // ============================================================================
    // Note: HUD Draw implementation deferred until engine support confirmed.
    // Currently using ihuddraw and iprint for notifications.
    // ============================================================================

    player_hud_manager:
    // Empty placeholder - waiting for hud_draw documentation/examples
    // When implemented, this will:
    // 1. Track active players and their HUD elements
    // 2. Update kill/death counters on HUD
    // 3. Show achievement notifications
    // 4. Display session stats
    end

    // ============================================================================
    // HUD NOTIFICATION SYSTEM
    // ============================================================================

    show_hud_notification local.player local.message local.r local.g local.b:
    if (!local.player) { end }
    if (local.message == NIL || local.message == "") { end }

    if (local.r == NIL) { local.r = 1.0 }
    if (local.g == NIL) { local.g = 1.0 }
    if (local.b == NIL) { local.b = 1.0 }

    local.index = 80 // HUD index 80 (safer range)
    
    ihuddraw_virtualsize local.player local.index 1
    ihuddraw_align local.player local.index "center" "top"
    ihuddraw_rect local.player local.index 0 50 800 20
    ihuddraw_font local.player local.index "verdana-14"
    ihuddraw_color local.player local.index local.r local.g local.b
    ihuddraw_timer local.player local.index 5.0 1.0
    ihuddraw_string local.player local.index local.message

    // Fallback for players with HUD disabled/broken
    local.player iprint (">>> " + local.message)
end

// ============================================================================
// CONSOLE COMMANDS
// ============================================================================
// These commands integrate with the SMF forum login token system.
// Players generate tokens at the forum and use them in-game to link identities.
// Once authenticated, the SMF member_id is used for all stat tracking.
// ============================================================================

// Wrapper for seed command (external script)
seed_cmd_wrapper local.player local.args:
    thread global/seeder.scr::cmd_seed local.player local.args
end

cmd_login local.player local.args:
    dprintln "cmd_login called"

           
    if (local.args.size < 1) {
        local.player iprint "Usage: login <token>"
        local.player iprint "Get your token from the forum: /action=mohaatoken"
        end
    }
    
    local.token = local.args
    
    local.player iprint "Verifying login token..."
    dprintln ("Player " + local.player.netname + " attempting auth with SMF token")
    
    // HUD Notification: Verifying
    thread show_hud_notification local.player "Verifying Token..." 1.0 1.0 0.0 // Yellow
    
    // Call SMF auth API endpoint
    // This verifies the token and returns the SMF member_id
    local.url = game.api_base_url + "/api/v1/auth/verify"

    // Construct JSON payload manually
    local.data = "{"
    local.data = local.data + "\"token\": \"" + local.token + "\","
    local.data = local.data + "\"player_guid\": \"" + (getclientnum local.player) + "\"," // TODO: Use real GUID if available
    local.data = local.data + "\"player_name\": \"" + local.player.netname + "\","
    local.data = local.data + "\"server_id\": \"" + game.server_id + "\","
    local.data = local.data + "\"server_ip\": \"" + (getcvar "net_ip") + "\","
    local.data = local.data + "\"server_port\": " + (getcvar "net_port")
    local.data = local.data + "}"

    // No longer storing global reference to avoid race conditions
    // level.pending_auth_player = local.player  <-- REMOVED

    dprintln ("[OPM] POST auth verify: " + local.url + " DATA: " + local.data)
    curl_post local.url NIL local.data on_smf_auth_verify
end

cmd_logout local.player local.args:
    if (!local.player.is_authenticated) {
        local.player iprint "You are not logged in."
        end
    }
    
    // Send logout notification to SMF (JSON)
    local.url = game.api_base_url + "/api/v1/auth/smf-logout"

    local.data = "{"
    local.data = local.data + "\"forum_user_id\": " + local.player.smf_member_id + ","
    local.data = local.data + "\"player_guid\": \"" + (getclientnum local.player) + "\"" // Sending clientnum/guid reference
    local.data = local.data + "}"
            
    dprintln ("[OPM] POST logout: " + local.url + " DATA: " + local.data)
    curl_post local.url NIL local.data on_smf_logout_response // Callback needed? Or just assume success.
            
    // Clear local state immediately
    local.player.is_authenticated = 0
    local.player.smf_member_id = 0
    local.player.smf_member_name = NIL
            
    local.player iprint "You have been logged out."
    dprintln ("Player " + local.player.netname + " logged out locally")
    
    // HUD Notification: Logged Out
    thread show_hud_notification local.player "Logged Out" 0.7 0.7 0.7 // Grey
end

cmd_claim local.player local.args:
// This is now handled through the SMF login system
// Players link their identity by logging in with their forum token
    local.player iprint "Identity linking is now done through forum login."
    local.player iprint "Visit the forum and generate a login token, then use login <token>"
end

cmd_stats local.player local.args:
    local.player iprint "Fetching your stats..."
    
    // Use SMF member_id if authenticated, otherwise search by Name
    if (local.player.is_authenticated && local.player.smf_member_id > 0) {
        local.url = game.api_base_url + "/api/v1/stats/member/" + local.player.smf_member_id
    } else {
        // Fallback to name search for unauthenticated players
        // Note: Names with spaces might need encoding if engine supports it, or use simple concatenation
        local.url = game.api_base_url + "/api/v1/stats/player/name/" + local.player.netname
    }
    
    dprintln ("[OPM] GET stats: " + local.url)
    local.headers = makearray
        "Accept" "application/json"
    endarray

    curl_get local.url local.headers on_stats_response
end

cmd_whoami local.player local.args:
    if (local.player.is_authenticated) {
        local.player iprint ("Logged in as: " + local.player.smf_member_name + " (ID: " + local.player.smf_member_id + ")")
    } else {
        local.player iprint "Not logged in. Use `login <token>` to authenticate."
    }
end

// ============================================================================
// MATCH LIFECYCLE EVENTS
// ============================================================================

send_match_start:
    local.rnd = uuid_string 16
    game.match_id = "match_" + game.session_id + "_" + local.rnd
    game.round_number = 1
    
    local.json = waitthread global/tracker_common.scr::build_base_json "match_start"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "map_name" game.map_name 1)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "gametype" (getcvar "g_gametype") 1)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "timelimit" (getcvar "timelimit") 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "fraglimit" (getcvar "fraglimit") 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "maxclients" (getcvar "sv_maxclients") 0)
    
    thread global/tracker_common.scr::queue_event local.json
    dprintln ("MATCH START: " + game.match_id)
end

send_match_end local.winning_team local.allies_score local.axis_score:
    if (local.winning_team == NIL) { local.winning_team = "unknown" }
    if (local.allies_score == NIL) { local.allies_score = 0 }
    if (local.axis_score == NIL) { local.axis_score = 0 }
    local.round = game.round_number
    local.map = game.map_name
    local.duration = gettime - game.match_start_time
    if (local.round == NIL) { local.round = 0 }
    if (local.map == NIL) { local.map = "unknown" }
    if (local.duration == NIL) { local.duration = 0 }
    local.json = waitthread global/tracker_common.scr::build_base_json "match_end"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "server_id" game.server_id 1)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "map_name" local.map 1)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "duration" local.duration 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "winning_team" local.winning_team 1)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "allies_score" local.allies_score 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "axis_score" local.axis_score 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "total_rounds" local.round 0)
    
    thread global/tracker_common.scr::queue_event local.json
    dprintln ("MATCH END: " + game.match_id + " Winner: " + local.winning_team)
end

send_round_start:
    game.round_number = (game.round_number + 1)
    if (game.round_number == NIL) { game.round_number = 1 }

    local.json = waitthread global/tracker_common.scr::build_base_json "round_start"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "round_number" game.round_number 0)

    thread global/tracker_common.scr::queue_event local.json
end

send_round_end local.winning_team:
    local.round = game.round_number
    if (local.round == NIL) { local.round = 0 }
    if (local.winning_team == NIL) { local.winning_team = "unknown" }
    local.json = waitthread global/tracker_common.scr::build_base_json "round_end"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "round_number" local.round 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "winning_team" local.winning_team 1)

    thread global/tracker_common.scr::queue_event local.json
end

heartbeat_loop:
    wait 30

    local.round = game.round_number
    local.allies = game.allies_score
    local.axis = game.axis_score
    local.pcount = game.playercount
    if (local.round == NIL) { local.round = 0 }
    if (local.allies == NIL) { local.allies = 0 }
    if (local.axis == NIL) { local.axis = 0 }
    if (local.pcount == NIL) { local.pcount = 0 }

    local.json = waitthread global/tracker_common.scr::build_base_json "heartbeat"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "round_number" local.round 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "allies_score" local.allies 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "axis_score" local.axis 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "player_count" local.pcount 0)

    thread global/tracker_common.scr::queue_event local.json
    thread heartbeat_loop
end

debug_sync_loop:
    while (1) {
        wait 5
        local.debug_val = getcvar "opm_tracker_debug"
        if (local.debug_val != "") {
            game.tracker_debug = (int local.debug_val)
        }
    }
end

// ============================================================================
// COMBAT EVENT HANDLERS
// ============================================================================
// MOVED TO: global/tracker_combat_ext.scr
// ============================================================================

// ============================================================================
// MOVEMENT EVENT HANDLERS
// ============================================================================

on_player_jump local.player:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_jump | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    local.json = waitthread global/tracker_common.scr::build_base_json "jump"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    
    thread global/tracker_common.scr::queue_event local.json
end

on_player_land local.player local.height:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_land | Player: " local.player " | Height: " local.height
    if (local.player == NIL) { end }
    if (!local.player) { end }
    if (local.height == NIL) { local.height = 0 }
    local.json = waitthread global/tracker_common.scr::build_base_json "land"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "fall_height" local.height 0)
    
    thread global/tracker_common.scr::queue_event local.json
end

on_player_crouch local.player:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_crouch | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    local.player.tracker_stance = "crouch"
    local.json = waitthread global/tracker_common.scr::build_base_json "crouch"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    
    thread global/tracker_common.scr::queue_event local.json
end

on_player_prone local.player:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_prone | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    local.player.tracker_stance = "prone"
    local.json = waitthread global/tracker_common.scr::build_base_json "prone"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    
    thread global/tracker_common.scr::queue_event local.json
end

on_player_distance local.player local.walked local.sprinted local.swam local.driven:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_distance | Player: " local.player " | Walked: " local.walked " | Sprinted: " local.sprinted
    if (local.player == NIL) { end }
    if (!local.player) { end }
    if (local.walked == NIL) { local.walked = 0 }
    if (local.sprinted == NIL) { local.sprinted = 0 }
    if (local.swam == NIL) { local.swam = 0 }
    if (local.driven == NIL) { local.driven = 0 }
    local.json = waitthread global/tracker_common.scr::build_base_json "distance"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "walked" local.walked 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "sprinted" local.sprinted 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "swam" local.swam 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "driven" local.driven 0)
    
    thread global/tracker_common.scr::queue_event local.json
end

on_player_movement local.type local.time:
    if (local.player == NIL) { end }
    if (!local.player) { end }
    if (local.player.tracker_stance == NIL) { local.player.tracker_stance = "stand" }
    
    if (local.player.tracker_stance == "stand") {
        local.sprinted = local.time
        if (local.sprinted == NIL) { local.sprinted = 0 }
        local.swam = 0.0
        local.driven = 0.0
    } else if (local.player.tracker_stance == "swim") {
            local.swam = local.time
            if (local.swam == NIL) { local.swam = 0 }
            local.sprinted = 0.0
            local.driven = 0.0
        } else if (local.player.tracker_stance == "drive") {
                local.driven = local.time
                if (local.driven == NIL) { local.driven = 0 }
                local.sprinted = 0.0
                local.swam = 0.0
            } else {
                local.sprinted = 0.0
                local.swam = 0.0
                local.driven = 0.0
            }
    
    local.json = waitthread global/tracker_common.scr::build_base_json "player_movement"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "sprinted" local.sprinted 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "swam" local.swam 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "driven" local.driven 0)

    thread global/tracker_common.scr::queue_event local.json
end

// ============================================================================
// INTERACTION EVENT HANDLERS
// ============================================================================

on_ladder_mount local.player local.ladder:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_ladder_mount | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    local.json = waitthread global/tracker_common.scr::build_base_json "ladder_mount"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    
    thread global/tracker_common.scr::queue_event local.json
end

on_ladder_dismount local.player local.ladder:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_ladder_dismount | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    local.json = waitthread global/tracker_common.scr::build_base_json "ladder_dismount"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    
    thread global/tracker_common.scr::queue_event local.json
end

// MOVED TO: global/tracker_items_ext.scr

on_player_use local.player local.entity:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_player_use | Player: " local.player " | Entity: " local.entity
    if (local.player == NIL) { end }
    if (!local.player) { end }
    if (local.entity == NIL) { local.entity = "unknown" }
    local.json = waitthread global/tracker_common.scr::build_base_json "use"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "entity" local.entity 1)
    
    thread global/tracker_common.scr::queue_event local.json
end

// ============================================================================
// SESSION EVENT HANDLERS
// ============================================================================

on_client_connect local.clientnum:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_client_connect | ClientNum: " local.clientnum
    if (local.clientnum == NIL) { local.clientnum = -1 }
    local.json = waitthread global/tracker_common.scr::build_base_json "connect"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json self "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "client_num" local.clientnum 0)
    
    thread global/tracker_common.scr::queue_event local.json
end

on_client_disconnect local.player:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_client_disconnect | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    local.json = waitthread global/tracker_common.scr::build_base_json "disconnect"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    
    thread global/tracker_common.scr::queue_event local.json
end

on_client_begin local.player:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_client_begin | Player: " local.player
    if (local.player == NIL) { end }
    if (!local.player) { end }
    // Initialize session-based counters
    local.player.shots_fired = 0
    local.player.shots_hit = 0
        
    // Initialize stance
    local.player.tracker_stance = "stand"

    local.json = waitthread global/tracker_common.scr::build_base_json "client_begin"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"

    thread global/tracker_common.scr::queue_event local.json
    
    // Start per-player accuracy summary thread
    thread player_accuracy_loop local.player
end

player_accuracy_loop local.player:
    while (local.player) {
        wait 10 // Every 10 seconds send summary
        
        if (!local.player) { end }

        if (local.player.shots_fired > 0) {
            local.json = waitthread global/tracker_common.scr::build_base_json "accuracy_summary"
            local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
            local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "fired" local.player.shots_fired 0)
            local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "hits" local.player.shots_hit 0)
            
            thread global/tracker_common.scr::queue_event local.json
        }
    }
end

on_team_join local.player local.old_team local.new_team:
    waitthread global/tracker_common.scr::debug_log_var "EVENT: on_team_join | Player: " local.player " | NewTeam: " local.new_team
    if (local.player == NIL) { end }
    if (!local.player) { end }
    if (local.old_team == NIL) { local.old_team = "unknown" }
    if (local.new_team == NIL) { local.new_team = "unknown" }
    local.json = waitthread global/tracker_common.scr::build_base_json "team_join"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "old_team" local.old_team 1)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "new_team" local.new_team 1)

    thread global/tracker_common.scr::queue_event local.json
end

// on_player_say is handled in tracker_interaction_ext.scr

// ============================================================================
// HTTP TRANSPORT LAYER
// ============================================================================


on_http_callback local.success local.response local.http_code:
    if (game.tracker_debug) {
        if (local.success) {
            dprintln ("HTTP OK [" + local.http_code + "]")
        } else {
            dprintln ("HTTP FAIL [" + local.http_code + "]: " + local.response)
        }
    }
end

// ============================================================================
// SMF AUTHENTICATION CALLBACKS
// ============================================================================
// These handle responses from the SMF login token verification system.
// On success, we store the SMF member_id on the player for use in all events.
// ============================================================================

on_smf_auth_verify local.success local.response local.http_code:
    dprintln ("SMF Auth response: " + local.response)
    if (local.success && local.http_code == 200) {
        // Parse JSON response to get member_id and member_name
        // Response format: {"valid":true,"forum_user_id":123,"member_name":"PlayerName","player_guid":"0","message":"..."}
        dprintln ("SMF Auth response: " + local.response)
        
        // 1. EXTRACT DATA
        // New Keys: forum_user_id, member_name, player_guid
        local.member_id = waitthread global/tracker_common.scr::json_get_int local.response "forum_user_id"
        local.member_name = waitthread global/tracker_common.scr::json_get_string local.response "member_name"
            
        // Extract the GUID (clientnum) correctly based on JSON format (it might be int or string)
        // In cmd_login we sent clientnum as "player_guid". API echoes it back.
        // It might come back as string "0", need to handle that.
        local.target_clientnum = waitthread global/tracker_common.scr::json_get_int local.response "player_guid"
        if (local.target_clientnum == NIL) {
            // Try getting as string and casting if safe? 
            // json_get_int usually handles numeric strings.
            // Fallback check
        }

        // 2. FIND PLAYER BY CLIENTNUM
        local.player = NIL
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if ((getclientnum $player[local.i]) == local.target_clientnum) {
                local.player = $player[local.i]
                break
            }
        }

        // If player not found (disconnected?), abort
        if (!local.player) {
            dprintln ("SMF Auth: Player with clientnum " + local.target_clientnum + " not found (disconnected?)")
            end
        }
        
        if (local.member_id > 0) {
            // SUCCESS - Store SMF identity on player
            local.player.is_authenticated = 1
            local.player.smf_member_id = local.member_id
            local.player.smf_member_name = local.member_name
            // Use the token they just sent (we don't have it here in callback unless echoed, 
            // but we actually store it in pending_auth_token on player earlier... 
            // Wait, simply reading it from player is fine now that we found the RIGHT player)
            local.player.auth_token = local.player.pending_auth_token
            
            local.player iprint ("Welcome, " + local.member_name + "! You are now logged in.")
            local.player iprint "Your stats will be tracked to your forum account."
            dprintln ("SMF Auth SUCCESS: " + local.player.netname + " -> member_id=" + local.member_id)
            
            // HUD Notification: Success
            thread show_hud_notification local.player ("Welcome " + local.member_name + "!") 0.0 1.0 0.0 // Green
            
            // Send login event to API with SMF member_id
            thread send_player_auth_event local.player
        } else {
            local.player.is_authenticated = 0
            local.player iprint "Login failed: Could not verify token."
            dprintln ("SMF Auth FAIL: No member_id in response")
            // HUD Notification: Fail
            thread show_hud_notification local.player "Login Failed: Invalid Response" 1.0 0.0 0.0 // Red
        }
    } else {
        // For failures, we can't notify the specific player easily without the GUID echoed in error response.
        // If the API returns JSON even on error with GUID, we could parse it.
        // Assuming generic fail for now or we could parse response if it follows same structure.
        dprintln ("SMF Auth FAIL: " + local.http_code + " - " + local.response)
    }
end

send_player_auth_event local.player:
    local.json = waitthread global/tracker_common.scr::build_base_json "player_auth"
    local.json = waitthread global/tracker_common.scr::add_player_json_fields local.json local.player "player"
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "smf_member_id" local.player.smf_member_id 0)
    local.json = local.json + "," + (waitthread global/tracker_common.scr::build_json_field "smf_member_name" local.player.smf_member_name 1)

    thread global/tracker_common.scr::queue_event local.json
end

on_auth_verify local.success local.response local.http_code:
// Legacy callback - redirect to SMF auth
    if (local.success && local.http_code == 200) {
        dprintln ("Legacy auth verified: " + local.response)
        self iprint "Authentication successful!"
    } else {
        dprintln ("Legacy auth failed: " + local.response)
        self iprint "Authentication failed. Check your token."
    }
end

on_claim_response local.success local.response local.http_code:
    if (local.success && local.http_code == 200) {
        self iprint "Identity claimed! Your stats are now linked."
    } else if (local.http_code == 404) {
            self iprint "Invalid claim code. Try again."
        } else {
            self iprint "Claim failed. Try again later."
        }
end

on_stats_response local.success local.response local.http_code:
// We need to find the player again because callbacks are context-less in this engine build
// Actually, we should have the player entity passed or recovered.
// For now, if we can't find the player, we just log to console.
    if (local.success) {
        dprintln ("Stats: " + local.response)
    } else {
        dprintln ("Could not fetch stats.")
    }
end

// ============================================================================
// ENGINE LIFE-CYCLE HANDLERS (New OPM Spec)
// ============================================================================

on_server_process_start:
    dprintln "------------------------------------------------"
    dprintln "OPM TRACKER: Server Process Start"
    dprintln "------------------------------------------------"
    // Handle registration once per process
    thread global/register.scr::check_registration
end

on_server_process_quit:
    dprintln "------------------------------------------------"
    dprintln "OPM TRACKER: Server Process Quit"
    dprintln "------------------------------------------------"
    // Final emergency flush
    waitthread global/tracker_common.scr::flush_queue
end

on_map_init:
    if (game.tracker_debug) {
        dprintln "OPM TRACKER: Map Init"
    }
    thread global/tracker_gameflow_ext.scr::on_map_init
end

on_map_start:
    dprintln "------------------------------------------------"
    dprintln "OPM TRACKER: Map Start"
    dprintln "------------------------------------------------"
    // Re-initialize map/round state
    game.round_number = 1
    game.match_start_time = gettime
    
    // Call extension and send match_start telemetry
    thread global/tracker_gameflow_ext.scr::on_map_start
    thread send_match_start
end

on_map_ready:
    if (game.tracker_debug) {
        dprintln "OPM TRACKER: Map Ready (Entities Spawned)"
    }
    thread global/tracker_gameflow_ext.scr::on_map_ready (getcvar "mapname") (getcvar "g_gametype")
end

on_map_shutdown:
    dprintln "------------------------------------------------"
    dprintln "OPM TRACKER: Map Shutdown"
    dprintln "------------------------------------------------"
    
    // Call extension
    thread global/tracker_gameflow_ext.scr::on_map_shutdown

    // Final map-level flush
    waitthread global/tracker_common.scr::flush_queue
end
